<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"baidu.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="理想情况下，直接在Linux计算机上安装Docker，这样就不必处理在宿主操作系统内运行的虚拟机中运行容器的额外复杂性。但是，如果使用的是macOS或Windows，并且不知道如何设置Linux虚拟机，那么Docker Desktop应用程序可以完成设置。运行容器的Docker命令行（CLI）工具将安装在宿主操作系统上，但Docker守护进程（daemon）将在虚拟机内运行，它所创建的所有容器也将">
<meta property="og:type" content="article">
<meta property="og:title" content="亲自探索容器">
<meta property="og:url" content="http://baidu.com/2024/08/04/k8s-in-action/explore-container-hands-on/index.html">
<meta property="og:site_name" content="不吃陈皮">
<meta property="og:description" content="理想情况下，直接在Linux计算机上安装Docker，这样就不必处理在宿主操作系统内运行的虚拟机中运行容器的额外复杂性。但是，如果使用的是macOS或Windows，并且不知道如何设置Linux虚拟机，那么Docker Desktop应用程序可以完成设置。运行容器的Docker命令行（CLI）工具将安装在宿主操作系统上，但Docker守护进程（daemon）将在虚拟机内运行，它所创建的所有容器也将">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://baidu.com/assets/image/k8s-in-action/17.png">
<meta property="og:image" content="http://baidu.com/assets/image/k8s-in-action/18.png">
<meta property="article:published_time" content="2024-08-04T10:51:00.000Z">
<meta property="article:modified_time" content="2024-08-05T14:21:09.726Z">
<meta property="article:author" content="buchichenpi">
<meta property="article:tag" content="容器">
<meta property="article:tag" content="k8s">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://baidu.com/assets/image/k8s-in-action/17.png">


<link rel="canonical" href="http://baidu.com/2024/08/04/k8s-in-action/explore-container-hands-on/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://baidu.com/2024/08/04/k8s-in-action/explore-container-hands-on/","path":"2024/08/04/k8s-in-action/explore-container-hands-on/","title":"亲自探索容器"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>亲自探索容器 | 不吃陈皮</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">不吃陈皮</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">2</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">1</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">3</span></a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E4%B8%80%E4%B8%AAhello-world%E5%AE%B9%E5%99%A8"><span class="nav-number">1.</span> <span class="nav-text">运行一个hello-world容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%93%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8%E7%9A%84%E6%97%B6%E5%80%99%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.1.</span> <span class="nav-text">当运行容器的时候发生了什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E5%85%B6%E4%BB%96%E7%9A%84%E9%95%9C%E5%83%8F"><span class="nav-number">1.2.</span> <span class="nav-text">运行其他的镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%90%86%E8%A7%A3%E5%AE%B9%E5%99%A8tags"><span class="nav-number">1.3.</span> <span class="nav-text">理解容器tags</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8%E5%8C%96%E7%9A%84-Node-js-Web-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">2.</span> <span class="nav-text">创建容器化的 Node.js Web 应用程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AADockerfile%E6%9D%A5%E6%9E%84%E5%BB%BA%E5%AE%B9%E5%99%A8%E6%98%A0%E5%83%8F"><span class="nav-number">3.</span> <span class="nav-text">创建一个Dockerfile来构建容器映像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F"><span class="nav-number">4.</span> <span class="nav-text">构建容器镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%90%86%E8%A7%A3%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F%EF%BC%88image%EF%BC%89"><span class="nav-number">4.1.</span> <span class="nav-text">理解如何构建镜像（image）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%90%86%E8%A7%A3%E9%95%9C%E5%83%8F%E4%B8%AD%E7%9A%84%E5%B1%82%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">4.2.</span> <span class="nav-text">理解镜像中的层是什么</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">buchichenpi</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://baidu.com/2024/08/04/k8s-in-action/explore-container-hands-on/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="buchichenpi">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不吃陈皮">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="亲自探索容器 | 不吃陈皮">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          亲自探索容器
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-04 18:51:00" itemprop="dateCreated datePublished" datetime="2024-08-04T18:51:00+08:00">2024-08-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-08-05 22:21:09" itemprop="dateModified" datetime="2024-08-05T22:21:09+08:00">2024-08-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/k8s%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">k8s实战笔记</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>理想情况下，直接在Linux计算机上安装Docker，这样就不必处理在<strong>宿主操作系统内运行</strong>的<strong>虚拟机</strong>中<strong>运行容器</strong>的额外复杂性。但是，如果使用的是macOS或Windows，并且不知道如何设置Linux虚拟机，那么Docker Desktop应用程序可以完成设置。运行容器的Docker命令行（CLI）工具将安装在宿主操作系统上，但Docker守护进程（daemon）将在虚拟机内运行，它所创建的所有容器也将如此。</p>
<p>Docker平台由许多组件组成，但只需要安装Docker Engine即可运行容器。如果使用的是macOS或Windows，需要先安装Docker Desktop。Docker文档地址：<a target="_blank" rel="noopener" href="https://docs.docker.com/get-docker/">https://docs.docker.com/get-docker/</a>。</p>
<h2 id="运行一个hello-world容器"><a href="#运行一个hello-world容器" class="headerlink" title="运行一个hello-world容器"></a>运行一个hello-world容器</h2><p>为了回显’hello-world’，需要先从Docker Hub中拉取一个叫<code>busybox</code>的镜像。<code>busybox</code>是一个可执行文件，它结合了许多标准的UNIX命令行工具，如echo、ls、gzip。当然，还有其他的镜像可以做到执行回显命令。</p>
<p>可以使用单个<code>docker run</code>命令完成下载指定的映像和在其中运行的命令。要运行简单的Hello world容器，请执行以下列表中显示的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker run busybox <span class="built_in">echo</span> <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">Unable to find image <span class="string">&#x27;busybox:latest&#x27;</span> locally</span><br><span class="line">latest: Pulling from library/busybox</span><br><span class="line">213a27df5921: Pull complete</span><br><span class="line">Digest: sha256:9ae97d36d26566ff84e8893c64a6dc4fe8ca6d1144bf5b87b2b85a32def253c7</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> busybox:latest</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>

<h3 id="当运行容器的时候发生了什么？"><a href="#当运行容器的时候发生了什么？" class="headerlink" title="当运行容器的时候发生了什么？"></a>当运行容器的时候发生了什么？</h3><p>下图展示了当运行<code>docker run</code>命令的时候发生了什么<br><img src="/../../assets/image/k8s-in-action/17.png" alt="17"><br>将镜像下载到您的计算机后，Docker 守护进程根据该镜像创建了一个容器，并在其中执行了 echo 命令。该命令将文本打印到标准输出，然后进程终止，容器停止。</p>
<h3 id="运行其他的镜像"><a href="#运行其他的镜像" class="headerlink" title="运行其他的镜像"></a>运行其他的镜像</h3><p>运行其他现有的容器镜像与运行busybox镜像非常相似。实际上，它通常甚至更简单，因为通常不需要像在前面的示例中的echo命令那样指定要执行的命令。要执行的命令通常写在镜像本身中，但可以在运行时覆盖它。</p>
<p>例如，如果想运行Redis数据存储，可以在<a target="_blank" rel="noopener" href="http://hub.docker.com/">http://hub.docker.com</a>或其他公共注册中心找到镜像名称。对于Redis来说，其中一个镜像被称为redis:alpine，所以可以像这样运行它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run redis:alpine</span><br></pre></td></tr></table></figure>
<h3 id="理解容器tags"><a href="#理解容器tags" class="headerlink" title="理解容器tags"></a>理解容器tags</h3><p>以redis容器为例，打开hub里redis的搜索结果<a target="_blank" rel="noopener" href="https://hub.docker.com/_/redis/tags">https://hub.docker.com/_&#x2F;redis&#x2F;tags</a>可以看到latest、buster, alpine，同样也有5.0.7-buster, 5.0.7-alpine等等。</p>
<p>Docker 允许你在同一名称下拥有同一镜像的多个版本或变体。每个变体都有一个唯一的标签（tag）。如果你引用镜像时没有明确指定标签，Docker 会假设你指的是特殊的 latest 标签。在上传一个新版本的镜像时，镜像的制作者通常会同时用实际的版本号以及 latest 来标记它。当你想要运行一个镜像的最新版本时，应该使用 latest 标签而不是指定具体的版本号。</p>
<p>即使是对于单个版本，镜像通常也有几种变体。对于 Redis5.0.7，有 5.0.7-buster 和 5.0.7-alpine。它们两个都包含相同版本的 Redis，但是它们所基于的基础镜像不同。5.0.7-buster 是基于 Debian 的“Buster”版本，而 5.0.7-alpine 是基于 Alpine Linux 基础镜像，这是一个非常精简的镜像，总共只有 5MB——它只包含了你在典型 Linux 发行版中看到的一小部分已安装二进制文件。</p>
<p>要运行镜像的特定版本和&#x2F;或变体，请在镜像名称中指定标签。例如，要运行 5.0.7-alpine 标签的镜像，你将执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run redis:5.0.7-alpine</span><br></pre></td></tr></table></figure>

<h2 id="创建容器化的-Node-js-Web-应用程序"><a href="#创建容器化的-Node-js-Web-应用程序" class="headerlink" title="创建容器化的 Node.js Web 应用程序"></a>创建容器化的 Node.js Web 应用程序</h2><p>下面创建一个简单的 Node.js Web 应用程序，并将其打包成一个容器镜像。这个应用程序将接受 HTTP 请求，并响应其正在运行的计算机的主机名。</p>
<p>这样，你将看到，尽管容器中的应用程序像其他任何进程一样在宿主机上运行，但它看到的主机名与宿主机的主机名不同。这在以后将应用程序部署到 Kubernetes 并进行扩展（水平扩展，即运行应用程序的多个实例）时非常有用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Listing 2.2 A simple Node.js web application: app.js</span><br><span class="line">const http = require(&#x27;http&#x27;);</span><br><span class="line">const os = require(&#x27;os&#x27;);</span><br><span class="line"></span><br><span class="line">const listenPort = 8080;</span><br><span class="line"></span><br><span class="line">console.log(&quot;Kubia server starting...&quot;);</span><br><span class="line">console.log(&quot;Local hostname is &quot; + os.hostname());</span><br><span class="line">console.log(&quot;Listening on port &quot; + listenPort);</span><br><span class="line"></span><br><span class="line">var handler = function(request, response) &#123;</span><br><span class="line">  let clientIP = request.connection.remoteAddress;</span><br><span class="line">  console.log(&quot;Received request for &quot;+request.url+&quot; from &quot;+clientIP);</span><br><span class="line">  response.writeHead(200);</span><br><span class="line">  response.write(&quot;Hey there, this is &quot;+os.hostname()+&quot;. &quot;);</span><br><span class="line">  response.write(&quot;Your IP is &quot;+clientIP+&quot;. &quot;);</span><br><span class="line">  response.end(&quot;\n&quot;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var server = http.createServer(handler);</span><br><span class="line">server.listen(listenPort);</span><br></pre></td></tr></table></figure>

<h2 id="创建一个Dockerfile来构建容器映像"><a href="#创建一个Dockerfile来构建容器映像" class="headerlink" title="创建一个Dockerfile来构建容器映像"></a>创建一个Dockerfile来构建容器映像</h2><p>构建容器镜像的时候需要创建一个包含多个指令的dockfile。首先，构建一个app.js，文件内容如上所示。然后，创建一个Dockfile，文件内容包含如下指令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM node:12</span><br><span class="line">ADD app.js /app.js</span><br><span class="line">ENTRYPOINT [<span class="string">&quot;node&quot;</span>, <span class="string">&quot;app.js&quot;</span>]</span><br></pre></td></tr></table></figure>
<p><code>FROM</code> 行定义了将要使用的容器镜像作为起点（即基础镜像）。在这个例子中，使用了 Node.js 的容器镜像，tag为12。在第二行中，将本地目录中的 app.js 文件以相同的名称（app.js）添加到镜像的根目录下。最后，在第三行中，指定了当执行镜像时 Docker 应该运行的命令，即<code>node app.js</code>。<br>为什么选择这个特定的镜像作为基础镜像。因为这个应用程序是一个 Node.js 应用程序，所以需要在镜像包含 node 二进制文件来运行该应用程序。也可以使用包含此二进制文件的任何镜像构造自己的镜像，甚至可以使用像 fedora 或 ubuntu 这样的 Linux 发行版基础镜像，并在构建镜像时将 Node.js 安装到容器中。但是，由于 node 镜像已经包含了运行 Node.js 应用程序所需的一切，因此从头开始构建镜像并没有意义。然而，在一些组织中，使用特定的基础镜像并在构建时向其添加软件可能是强制性的。</p>
<h2 id="构建容器镜像"><a href="#构建容器镜像" class="headerlink" title="构建容器镜像"></a>构建容器镜像</h2><p>Dockerfile 和 app.js 文件是构建镜像所需的一切。现在，将使用下一个列表中的命令构建名为 kubia:latest 的镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t kubia:latest .</span><br></pre></td></tr></table></figure>
<p>-t 选项指定了所需的镜像名称和标签，末尾的点（.）指定了包含 Dockerfile 和构建上下文（构建过程所需的所有文件）的目录的路径。</p>
<p>当构建过程完成后，新创建的镜像将存储在计算机的本地镜像库中。可以通过列出本地镜像来查看它，如下面的列表所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br></pre></td></tr></table></figure>
<h3 id="理解如何构建镜像（image）"><a href="#理解如何构建镜像（image）" class="headerlink" title="理解如何构建镜像（image）"></a>理解如何构建镜像（image）</h3><p>下图展示了构建镜像的过程：<br><img src="/../../assets/image/k8s-in-action/18.png" alt="18"><br>Docker CLI 工具本身并不执行构建操作。相反，整个目录的内容会上传到 Docker 守护进程（daemon），并由它来完成镜像的构建。CLI 工具和守护进程不一定在同一台计算机上。如果在非 Linux 系统（如 macOS 或 Windows）上使用 Docker，客户端位于主机操作系统（host os）中，但守护进程在 Linux 虚拟机内运行。但守护进程也可以在远程计算机上运行。</p>
<p>为了构建镜像，Docker 首先会从公共镜像仓库（在本例中为 Docker Hub）中拉取基础镜像（node:12），除非该镜像已经本地存储。然后，它会根据该镜像创建一个新的容器（container），并执行 Dockerfile 中的下一条指令。容器的最终状态会生成一个具有自己 ID 的新镜像。接着，构建过程会继续处理 Dockerfile 中剩余的指令。每条指令都会创建一个新的镜像。最后，最终的镜像会使用在 docker build 命令中通过 -t 标志指定的标签进行标记。</p>
<h3 id="理解镜像中的层是什么"><a href="#理解镜像中的层是什么" class="headerlink" title="理解镜像中的层是什么"></a>理解镜像中的层是什么</h3><p>在构建镜像时，Dockerfile 中的每个单独指令都会创建一个新的层。</p>
<p>在构建 kubia 镜像的过程中，在拉取基础镜像的所有层之后，Docker 会创建一个新层，并将 app.js 文件添加到该层中。然后，它会再创建一个仅包含镜像执行时运行的命令的层。这个最后的层随后被标记为 kubia:latest。</p>
<p>您可以通过运行<code>docker history</code>来查看镜像的层及其大小，如下所示。首先打印最上层的层。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">history</span> kubia:latest</span><br><span class="line">IMAGE          CREATED          CREATED BY                                      SIZE      COMMENT</span><br><span class="line">9e67beb141ec   51 seconds ago   ENTRYPOINT [<span class="string">&quot;node&quot;</span> <span class="string">&quot;app.js&quot;</span>]                    0B        buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      51 seconds ago   ADD app.js /app.js <span class="comment"># buildkit                   617B      buildkit.dockerfile.v0</span></span><br><span class="line">&lt;missing&gt;      2 years ago      /bin/sh -c <span class="comment">#(nop)  CMD [&quot;node&quot;]                 0B</span></span><br><span class="line">&lt;missing&gt;      2 years ago      /bin/sh -c <span class="comment">#(nop)  ENTRYPOINT [&quot;docker-entry…   0B</span></span><br><span class="line">&lt;missing&gt;      2 years ago      /bin/sh -c <span class="comment">#(nop) COPY file:4d192565a7220e13…   388B</span></span><br><span class="line">&lt;missing&gt;      2 years ago      /bin/sh -c <span class="built_in">set</span> -ex   &amp;&amp; <span class="keyword">for</span> key <span class="keyword">in</span>     6A010…   7.72MB</span><br><span class="line">&lt;missing&gt;      2 years ago      /bin/sh -c <span class="comment">#(nop)  ENV YARN_VERSION=1.22.18     0B</span></span><br><span class="line">&lt;missing&gt;      2 years ago      /bin/sh -c ARCH= &amp;&amp; dpkgArch=<span class="string">&quot;<span class="subst">$(dpkg --print…   73.2MB</span></span></span><br><span class="line"><span class="subst"><span class="string">&lt;missing&gt;      2 years ago      /bin/sh -c #(nop)</span>  ENV NODE_VERSION=12.22.12    0B</span></span><br><span class="line"><span class="string">&lt;missing&gt;      2 years ago      /bin/sh -c groupadd --gid 1000 node   &amp;&amp; use…   336kB</span></span><br><span class="line"><span class="string">&lt;missing&gt;      2 years ago      /bin/sh -c set -ex;  apt-get update;  apt-ge…   523MB</span></span><br><span class="line"><span class="string">&lt;missing&gt;      2 years ago      /bin/sh -c apt-get update &amp;&amp; apt-get install…   136MB</span></span><br><span class="line"><span class="string">&lt;missing&gt;      2 years ago      /bin/sh -c set -ex;  if ! command -v gpg &gt; /…   6.44MB</span></span><br><span class="line"><span class="string">&lt;missing&gt;      2 years ago      /bin/sh -c set -eux;  apt-get update;  apt-g…   21.7MB</span></span><br><span class="line"><span class="string">&lt;missing&gt;      2 years ago      /bin/sh -c #(nop)  CMD [&quot;</span>bash<span class="string">&quot;]                 0B</span></span><br><span class="line"><span class="string">&lt;missing&gt;      2 years ago      /bin/sh -c #(nop) ADD file:73f1db8536438ca89…   95.9MB</span></span><br></pre></td></tr></table></figure>
<p>大多数层都来自 node:12 镜像。最上面的两层对应于 Dockerfile 中的第二个和第三个指令（ADD 和 ENTRYPOINT）。</p>
<p>正如在<code>CREATED BY</code> 列中所看到的，每个层都是通过在容器中执行命令来创建的。除了使用 <code>ADD</code> 指令添加文件外，还可以在 <code>Dockerfile</code> 中使用其他指令。例如，RUN 指令在构建过程中在容器中执行命令。在上面的列表中有一个层，其中执行了 <code>apt-get update</code> 和一些附加的 <code>apt-get</code> 命令。<code>apt-get</code> 是 <code>Ubuntu</code> 包管理器的一部分，用于安装软件包。列表中显示的命令将一些软件包安装到镜像的文件系统中。</p>
<br>
<br>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%AE%B9%E5%99%A8/" rel="tag"># 容器</a>
              <a href="/tags/k8s/" rel="tag"># k8s</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/07/27/k8s-in-action/understanding-container/" rel="prev" title="容器简介">
                  <i class="fa fa-angle-left"></i> 容器简介
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">buchichenpi</span>
  </div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
